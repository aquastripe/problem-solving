# 題解

題目：https://atcoder.jp/contests/abc318/tasks

## E

假設測資為

```
7
9 1 9 2 9 3 9
```

其 index 與 value 對應如下：

```
Index: 1 2 3 4 5 6 7
Value: 9 1 9 2 9 3 9
```

那麼輸出為 10，列表如下：

| Index     | Value     |
|-----------|-----------|
| (1, 2, 3) | (9, 1, 9) |
| (1, 2, 5) | (9, 1, 9) |
| (1, 4, 5) | (9, 2, 9) |
| (1, 2, 7) | (9, 1, 9) |
| (1, 4, 7) | (9, 2, 9) |
| (1, 6, 7) | (9, 3, 9) |
| (3, 4, 5) | (9, 2, 9) |
| (3, 4, 7) | (9, 2, 9) |
| (3, 6, 7) | (9, 3, 9) |
| (5, 6, 7) | (9, 3, 9) |

分析：

1. 重複出現 2 次以上的數，這個數作為 $A_i = A_k$。
2. index 開頭為 $1, 3, 5$ 的次數分別為 $6, 3, 1$ 次。
3. 為何開頭為 $1$ 的有 $6$ 次？因為 index 結尾為 $3, 5, 7$ 的個數分別為 $1, 2, 3$，加起來總共為 $1+2+3=6$ 次。
4. 為何開頭為 $1$ 且結尾為 $7$ 的有 $3$ 次？因為中間夾了 $3$ 個 $A_j \neq A_i$ 數。
5. 為何中間夾了 $3$ 個 $A_j$ 數？因為 $[1, 7]$ 總共有 $7$ 個數，其中為 $A_i = A_k$ 的有 $4$ 個，把它們扣掉 $7-4=3$。

因此，寫成程式如下：

1. 透過 `defaultdict(list)` 儲存所有數值對應的 index，並且只留下 2 次以上的。
2. 對每一組寫個 for-loop 迭代每個開頭的數 (i.e. 上例的 $1, 3, 5$)。
3. 計算每個區間夾了多少個 $A_j$。

```python
from collections import defaultdict

N = int(input())
A = list(map(int, input().split()))

indices = defaultdict(list)
for i, a in enumerate(A):
    indices[a].append(i)

indices_list = list(filter(lambda item: len(item) >= 2, indices.values()))

count = 0
for indices in indices_list:
    for i in range(len(indices) - 1):
        for j in range(i + 1, len(indices)):
            nums_in_interval = indices[j] - indices[i] + 1
            nums_aj = nums_in_interval - (j - i + 1)
            count += nums_aj

print(count)
```

然而，算是算對了但會 TLE。關鍵是計算每個區間夾了多少個 $A_j$ 這一步也消耗一個 for-loop，也許有重複計算的地方可以節省下來？

另一種思路：先對 index 中間的數值進行排序，結果如下：

| Index     | Value     |
|-----------|-----------|
| (1, 2, 3) | (9, 1, 9) |
| (1, 2, 5) | (9, 1, 9) |
| (1, 2, 7) | (9, 1, 9) |
| (1, 4, 5) | (9, 2, 9) |
| (1, 4, 7) | (9, 2, 9) |
| (3, 4, 5) | (9, 2, 9) |
| (3, 4, 7) | (9, 2, 9) |
| (1, 6, 7) | (9, 3, 9) |
| (3, 6, 7) | (9, 3, 9) |
| (5, 6, 7) | (9, 3, 9) |

從這可以看出：

1. 將 $2, 4, 6$ 夾住的個數分別有 $3, 4, 3$ 個。
2. 將 $2$ 夾住的數，左邊有 $1$ 共 $1$ 個，右邊有 $3, 5, 7$ 共 $3$ 個。
3. 將 $4$ 夾住的數，左邊有 $1, 3$ 共 $2$ 個，右邊有 $5, 7$ 共 $4$ 個。
4. 從上面的規律可以看出，將中間的數夾幾次，可以計算左邊的數與右邊的數的所有組合，例如 $(1, 5), (1, 7), (3, 5), (3, 7)$，所有組合數的計算方式就是兩組個數相乘，也就是 $2 \times 2 = 4$。

所以，只要先找出所有中間的數 $A_j$，再計算所有左邊的數和右邊的數的個數相乘即可。

另外，也考慮把中間的數夾很多次的情形，例如：

```
5
9 1 2 9 9
```

| Index     | Value     |
|-----------|-----------|
| (1, 2, 4) | (9, 1, 9) |
| (1, 2, 5) | (9, 1, 9) |
| (1, 3, 4) | (9, 2, 9) |
| (1, 3, 5) | (9, 2, 9) |

夾在中間的數不管有幾個，計算左右兩邊個數是重複的，所以只要乘起來即可，也就是：

找到所有的區間，加總 左邊的個數 * 中間的個數 * 右邊的個數

總算是過了。不過我看到一個跑更快的：

```python
n = int(input())
a = [int(i) for i in input().split()]

counts = [0] * (n+1)
ind_sum = [0] * (n+1)

out = 0
for i in range(n):
    num = a[i]
    if counts[num] > 0:
        out += i * counts[num]
        out -= counts[num]
        out -= ind_sum[num]
        out -= counts[num] * (counts[num]-1) // 2
    counts[num] += 1
    ind_sum[num] += i
print(out)
```

這到底在算什麼？
